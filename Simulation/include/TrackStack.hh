#ifndef TrackStack_HH
#define TrackStack_HH

/**
 * @file    TrackStack.hh
 * @class   TrackStack
 * @author  M. Novak
 * @date    July 2023
 *
 * @brief A simple track-stack to handle both primary and secondary particle tracks.
 *
 * This stack holds tracks (all belonging to the same event), that are still to be
 * tracking (i.e. still need to call/instert to the appropriate `SteppingLoop`):
 * - at the begining of each event, (a) primary track is inserted into the stack
 *   (inside the `EventLoop::ProcessEvents()`) as the very first track (NOTE:
 *    assumed to have only one primary per event for simplicity)
 * - all secondaries, generated by the entire simulation of the event, are inserted
 *   when created (inside the appropriate `SteppingLoop`), i.e. pushed and later
 *   popped for tracking
 * - the event is completed when the track-stack becomes empty again
 *
 * A new event can be started then.
 */

#include <vector>

class G4HepEmTrack;

class TrackStack {
public:
   /** CTR */
    TrackStack();
    /** DTR */
   ~TrackStack() {}

  /** Pops a secondary track from the stack and writes to the input address.
    *
    * This method is called from `EventLoop::ProcessEvents()` before start tracking
    * a new track. It returns with the original index of the popped track or -1 when
    * the track is actually empty, i.e. no more track to pop.
    *
    * @param[in,out] track the address of the `G4HepEmTrack` where the next track should be popped, i.e. copied.
    * @return returns with the original index of the popped track or -1 if the there are no more tracks in the track
    */
  int PopInto(G4HepEmTrack& track);


  /** Can provide the type of the next track.
   *
   * Returns with an integer that encodes the type of the next track in the stack, i.e. the type of the track
   * that will be popped when calling `PopInto()` next time.
   *
   * @return an integer indicating the type of the next track:
   *         - -1 in case of \f$e^-\f$
   *         -  0 in case of \f$\gamma\f$
   *         - +1 in case of \f$e^+\f$
   *         - -999 if the stack is empty
   */
  int GetTypeOfNextTrack();


  /** Returns a reference to a secondary track that can be used to push a new track into the stack.
   *
   * This method is called whenever a new track needs to be inseted into the stack. The provided reference
   * can be used to fill the track infomation (the referenced track is re-set).
   *
   * @return A reference to a `G4HepEmTrack` that can be used to add a new track to the stack (by filling in its filed).
   */
  G4HepEmTrack&  Insert();


  /** Copying the content of the `from` to the `to` track.*/
  void Copy(G4HepEmTrack& from, G4HepEmTrack& to);


  /** Returns with the next track ID (track ID is incremented whenever this method is invoked).*/
  int  GetNextTrackID() { return fCurrentTrackID++; }
  /** Resets the track ID to zero.*/
  void ReSetTrackID()   { fCurrentTrackID=0; }



private:

  int fSize;                             ///< current capacity of the track stack
  int fCurIndx;                          ///< number of tracks used from the capacity
  int fCurrentTrackID;                   ///< current track ID
  std::vector<G4HepEmTrack> fTrackVect;  ///< the stack as a vector of tracks
};

#endif // TrackStack_HH
