/**
 * @file    HepEmShow.cc
 * @author  M. Novak
 * @date    July 2023
 *
 * @brief The main funtion of the `HepEmShow` application.
 *
 * The main of the `HepEmShow` application is responsible for setting up the
 * environment, lunch the simulation and write the results. This is done by:
 * - reading the input arguments provided at the execution of the application
 *   into an `InputParameters` object. (Note, these arguments provide
 *   configuration options).
 * - loading the `G4HepEm` data and parameters from file into a `G4HepEmState`
 *   (see the note below)
 * - constructing a `G4HepEmTLData` (also required by `G4HepEm` and encapsulates
 *   the random number generator and some track buffers) with its random number
 *   generator (utilising the local `URandom` generator)
 * - constructing and setting up the application `Geometry` according to the
 *   provided configuration input arguments (in `InputParameters`)
 * - constructing and setting up a `Results` structure that will be used to collect
 *   some data during the simulation
 * - constructing and setting up the `PrimaryGenerator` of the application according
 *   to the provided configuration input arguments (in `InputParameters`)
 * - the `EventLoop::ProcessEvents` method is invoked then to **perform the simulation**
 * - the simulation results are witten to file (and to the standard output) by
 *   invoking `WriteResults()` (from the `Results`)
 *
 * @note The `G4HepEm` data file is either the one included in the `HepEmShow`
 * repository (under `hepemshow/data/`) or generated by the auxiliary
 * `HepEmShow-DataGeneration` application. In the former case, the data file
 * contains all data that `G4HepEm` needs for the simulation for the 3 default
 * (`{"G4_Galactic", "G4_PbWO4", "G4_lAr"}`) materials, i.e. those used in the
 * default `Geometry` configuration.
 */



// G4HepEm related includes:
// - from G4HepEm/G4HepEmData: data (struct) definitions
#include "G4HepEmState.hh"
#include "G4HepEmData.hh"
#include "G4HepEmParameters.hh"
#include "G4HepEmMatCutData.hh"

// - from G4HepEm/G4HepEmDataJsonIO: data IO (i.e. to load the pre-generated data)
#include "G4HepEmDataJsonIO.hh"

// - for plugging in our local (`URandom`) random number generator
#include "G4HepEmTLData.hh"
#include "G4HepEmRandomEngine.hh"
#include "URandom.hh"

// Local includes:
#include "InputParameters.hh"
#include "Geometry.hh"
#include "PrimaryGenerator.hh"
#include "Results.hh"
#include "EventLoop.hh"


// System includes:
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

#include "sys/time.h"
#include <ctime>



/** The main function of the `HepEmShow` simulation application (see more in the description). */
int main(int argc, char* argv[]) {

  // `InputParameters` encapsulates the possible input parameters that are read by `GetOpt`
  InputParameters theInputParameters;
  GetOpt(argc, argv, theInputParameters);


  // `G4HepEmState` encapsulates G4HepEm (physics related) `data` and `parameters`
  // here we load the generated/delivered G4HepEm data from the file given as an input argument
  std::ifstream jsonIS{ theInputParameters.fG4HepEmDataFile.c_str() };
  G4HepEmState* theState = G4HepEmStateFromJson(jsonIS);


  // `G4HepEmTLData` encapsulates "thread-local" (i.e. TL) data like:
  // - the random number generator (will be constructed and set below)
  // - the primary/secondary tracks used to provide/receive tracks to/from the
  //   G4HepEm run-time functioinalities
  G4HepEmTLData*  theTLData = new G4HepEmTLData();
  // construct a HepEm random number generator, using our local uniform `URandom`
  // generator, then set it to be used in the above TLdata
  // NOTE: seed can be set as input argument
  URandom*             theURnd         = new URandom(GET_VALUE(theInputParameters.fPrimaryAndEvents.fRandomSeed));
  G4HepEmRandomEngine* theRandomEngine = new G4HepEmRandomEngine(theURnd);
  theTLData->SetRandomEngine(theRandomEngine);


  // `Geometry` describes the application geometry (i.e. the simplified sampling calorimeter)
  //  here we construct the application geometry and set its configurable properties like
  //  #layers, thickness of absorber and gap, etc.
  Geometry theGeometry;
  theGeometry.SetNumLayers(theInputParameters.fGeometry.fNumLayers);
  theGeometry.SetAbsThick(theInputParameters.fGeometry.fThicknessAbsorber);
  theGeometry.SetGapThick(theInputParameters.fGeometry.fThicknessGap);
  theGeometry.SetCaloSizeYZ(theInputParameters.fGeometry.fSizeTransverse);


  // `PrimaryGenerator` is used to produce primary particle/track when starting a new event
  // here we construct the primary generator and set its configurable properties like
  // primary particle kinetic energy and its type, i.e. e-,e+ or gamma (determined the charge), etc.
  PrimaryGenerator thePrimaryGenerator;
  double charge = theInputParameters.fPrimaryAndEvents.fParticleName == "e-" ? -1.0
                  : (theInputParameters.fPrimaryAndEvents.fParticleName == "gamma" ? 0.0 : +1.0);
  thePrimaryGenerator.SetCharge(charge);
  SET_GRADIENT(theInputParameters.fPrimaryAndEvents.fParticleEnergy, 1.0);
  thePrimaryGenerator.SetKinEnergy(theInputParameters.fPrimaryAndEvents.fParticleEnergy);
  // set primary particle position and direction (should not be changed)
  thePrimaryGenerator.SetPosition(theGeometry.GetPrimaryXposition(), 0.0, 0.0);
  thePrimaryGenerator.SetDirection(1.0, 0.0, 0.0);


  // `Results` encapsulates the data that we record during the simulation
  // here we construct one and set the properties of its histograms (as thery are used
  // to collect data per-layer and the number of layer is configurable input argument)
  Results theResult;
  theResult.fEdepPerLayer.ReSet("hist_Edep_PerLayer", 0, theGeometry.GetNumLayers(), theGeometry.GetNumLayers());
  theResult.fEdepDsqPerLayer.ReSet("hist_EdepDsq_PerLayer", 0, theGeometry.GetNumLayers(), theGeometry.GetNumLayers());
  theResult.fEdepSqPerLayer.ReSet("hist_EdepSq_PerLayer", 0, theGeometry.GetNumLayers(), theGeometry.GetNumLayers());
  theResult.fGammaTrackLenghtPerLayer.ReSet("hist_GamTrackL_PerLayer", 0, theGeometry.GetNumLayers(), theGeometry.GetNumLayers());
  theResult.fElPosTrackLenghtPerLayer.ReSet("hist_ElPosTrackL_PerLayer", 0, theGeometry.GetNumLayers(), theGeometry.GetNumLayers());


  // here we start the event processing: generate the required number of event and simulte each event.
  EventLoop::ProcessEvents(*theTLData, *theState, thePrimaryGenerator, theGeometry, theResult, theInputParameters.fPrimaryAndEvents.fNumEvents, theInputParameters.fRunVerbosity);


  // here we summarise the results and write them to file (the histograms) or to the screen
  WriteResults(theResult, theInputParameters.fPrimaryAndEvents.fNumEvents);


  // delete objects
  delete theRandomEngine;
  delete theURnd;
  delete theTLData;

  return 0;
}
